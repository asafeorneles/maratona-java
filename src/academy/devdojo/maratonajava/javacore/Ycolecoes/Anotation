BinarySearch: Basicamente, é uma forma de saber onde o objeto estaria na lista de acordo com o sort (Ordem na lista). Se temos uma lista
 com 5 objetos ordenador pelos iIDs: 1,2,3,4,5, logo se criarmos o 6 e usarmos o BinarySearch pra saber onde ele estaria, ele falaria que seria
 na ordem numero 6.

Equals: Uma caracteristica personalizavel por nós para as classes para que seus objetos possam ser comparados e únicos. É indispensável criar
 o equals e o hashCode quando formos trabalhar com collections.

HashCode: Um código que é dado para cada objeto. Também é personalizável por nós para que cada obeto criado tenha seu hashCode e seja único.

List: Uma interface que possui listas. Se tem o ArrayList por exemplo, que é um array onde possui vantagens. Não precisamos predefinir um tamanho
 para o ArrayList, é um array que cresce dinamicamente. Podemos ordenar de forma personalizada a ordem dos objetos da lista, usar o contais...
 Podemos usar também o LinkedList, que é uma Lista onde cada posição sabe sobre a posição anterior e a posterior. No caso de remoção de obetos
 da lista, é mais vantajoso.

Set: Uma interface que nos permite trabalhar com HashSet por exemplo. Como se fosse uma lista que armazena cada objeto de forma única.
 A vantagem do HashSet é que ela não permite objetos repetidos, fazendo essa distinção e organizaçao por meio do Hash de cada objeto.
 Tem também o LinkedHashSet, que não permite objetos repetidos mas mantém a ordem dos objetos na lista de acordo com a ordem que foi inserido por nós

NavigableSet: Uma interface que extende o Set e tem como característica trabalhar com Classes contable. Ela nos permite trabalhar por exemplo com o TreeSet.
 TreeSet: O TreeSet permanece com as características do Set(Evitar objetos repetidos na lista) mas agora ela ordena os objetos na listas de acordo com
  o que adotamos para ser comparado no comparable ou no comparator. Ou seja, ela nescessita que a classe tenha uma forma de ordenar sendo comparable ou comparator.

Map: Map é quase uma Collection. Ele trabalha com chaves e valores. Cada chave possui um valor e nós podemos definir o tipo da chave e valor.
 HashSet: Um map. Ele não permite que se tenha 2 chaves iguais. Podemos ter vários valores iguais para diferentes chaves mas apenas uma chave para cada valor.
  Se adicionarmos 2 chaves iguais com valores diferentes, o HashMap sobrescreve o valor.
  Em vêz de adicionarmos com .add, adicionamos com .put.

Queue: Fila. É uma interface que permite trabalhar com fila. FIFO (First in, first out). Ela tem suas coleçoes:
 PriorityQueue: Coleçao da queue. O interessante é que a priorityQueue nao trabalha como FIFO. Ela Permite adicionar e remover objetos de acordo
  com sua forma de ordenaçao, ou seja, o objeto tem que ser comparable ou ter um comparator. Ela não ordena os objetos quando estão em memória
  Mas sim quando damos uma ordem como remove, etc.
 Se usarmos a Queue como um LinkedList, aí sim teremos uma fila usando a FIFO. Exemplo: Queue<Paciente> filaNormal = new LinkedList<>();
 Aqui, ao removermos os pacientes, a fila irá remover por ordem de chegada.