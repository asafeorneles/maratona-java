Primeiro: o que temos
List<List<String>> cruzeiro = new ArrayList<>();

List<String> atacantes = List.of("Kaio Jorge", "Arroyo", "Gabigol");
List<String> volantes = List.of("Lucas Silva", "Lucas Romero", "Christian");
List<String> defensores = List.of("Villalba", "FabrÃ­cio Bruno", "CÃ¡ssio");

cruzeiro.add(atacantes);
cruzeiro.add(volantes);
cruzeiro.add(defensores);


ğŸ“¦ cruzeiro Ã© uma lista de listas â€” ou seja:

[
  [Kaio Jorge, Arroyo, Gabigol],
  [Lucas Silva, Lucas Romero, Christian],
  [Villalba, FabrÃ­cio Bruno, CÃ¡ssio]
]

ğŸ§© Quando usas .map(List::stream)
cruzeiro.stream()
        .map(List::stream)
        .forEach(System.out::println);


ğŸ‘‰ cruzeiro.stream() cria um Stream<List<String>>

Depois, o .map(List::stream) transforma cada List<String> em um Stream<String>.
Logo o tipo final Ã©:

Stream<Stream<String>>


ğŸ“¦ğŸ“¦ Um stream de streams.
Cada elemento impresso serÃ¡ algo como:

java.util.stream.ReferencePipeline$Head@6f496d9f
java.util.stream.ReferencePipeline$Head@723279cf
java.util.stream.ReferencePipeline$Head@10f87f48


Esses sÃ£o os â€œendereÃ§osâ€ dos Streams internos, e nÃ£o os nomes.

ğŸŒ€ Agora com .flatMap(List::stream)
cruzeiro.stream()
        .flatMap(List::stream)
        .forEach(System.out::println);


Aqui o que acontece Ã© o seguinte:

O flatMap vÃª que cada elemento (List<String>) vira um Stream<String>

E entÃ£o ele â€œachataâ€ todos esses streams em um sÃ³
â†’ Ou seja, junta tudo num Ãºnico fluxo de Strings.

O tipo final Ã©:

Stream<String>


E o resultado no console serÃ¡:

Kaio Jorge
Arroyo
Gabigol
Lucas Silva
Lucas Romero
Christian
Villalba
FabrÃ­cio Bruno
CÃ¡ssio